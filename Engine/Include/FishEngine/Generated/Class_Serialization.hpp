
/**************************************************
* auto generated by reflection system
**************************************************/

#include "../Rigidbody.hpp"
#include "../Light.hpp"
#include "../Material.hpp"
#include "../Collider.hpp"
#include "../Script.hpp"
#include "../Material.hpp"
#include "../Vector2.hpp"
#include "../Vector3.hpp"
#include "../Vector4.hpp"
#include "../Transform.hpp"
#include "../Texture.hpp"
#include "../Matrix4x4.hpp"
#include "../Animator.hpp"
#include "../ShaderProperty.hpp"
#include "../SphereCollider.hpp"
#include "../ShaderProperty.hpp"
#include "../Camera.hpp"
#include "../Frustum.hpp"
#include "../Object.hpp"
#include "../Component.hpp"
#include "../Shader.hpp"
#include "../TagManager.hpp"
#include "../Behaviour.hpp"
#include "../IntVector.hpp"
#include "../Quaternion.hpp"
#include "../Mesh.hpp"
#include "../ShaderCompiler.hpp"
#include "../IntVector.hpp"
#include "../IntVector.hpp"
#include "../Mesh.hpp"
#include "../Texture2D.hpp"
#include "../Renderer.hpp"
#include "../SkinnedMeshRenderer.hpp"
#include "../Texture.hpp"
#include "../Animator.hpp"
#include "../Bounds.hpp"
#include "../Application.hpp"
#include "../Animator.hpp"
#include "../Animator.hpp"
#include "../LayerMask.hpp"
#include "../CapsuleCollider.hpp"
#include "../Animator.hpp"
#include "../CameraController.hpp"
#include "../BoxCollider.hpp"
#include "../GameObject.hpp"
#include "../MeshFilter.hpp"
#include "../Scene.hpp"
#include "../Animator.hpp"
#include "../Animator.hpp"
#include "../Color.hpp"
#include "../MeshRenderer.hpp"
#include "../Skybox.hpp"
#include "../GameApp.hpp"
#include "../Ray.hpp"

namespace FishEngine
{
	
	// Rigidbody
	template<typename Archive>
	void Save ( Archive& archive, Rigidbody const & value )
	{
		archive << BaseClassWrapper<Component>(value);
		archive << make_nvp("m_mass", value.m_mass); // float
		archive << make_nvp("m_drag", value.m_drag); // float
		archive << make_nvp("m_angularDrag", value.m_angularDrag); // float
		archive << make_nvp("m_useGravity", value.m_useGravity); // bool
		archive << make_nvp("m_isKinematic", value.m_isKinematic); // bool
		archive << make_nvp("m_velocity", value.m_velocity); // FishEngine::Vector3
	}

	template<typename Archive>
	void Load ( Archive& archive, Rigidbody & value )
	{
		archive >> BaseClassWrapper<Component>(value);
		archive >> make_nvp("m_mass", value.m_mass); // float
		archive >> make_nvp("m_drag", value.m_drag); // float
		archive >> make_nvp("m_angularDrag", value.m_angularDrag); // float
		archive >> make_nvp("m_useGravity", value.m_useGravity); // bool
		archive >> make_nvp("m_isKinematic", value.m_isKinematic); // bool
		archive >> make_nvp("m_velocity", value.m_velocity); // FishEngine::Vector3
	}


	// Light
	template<typename Archive>
	void Save ( Archive& archive, Light const & value )
	{
		archive << BaseClassWrapper<Behaviour>(value);
		archive << make_nvp("m_type", value.m_type); // FishEngine::LightType
		archive << make_nvp("m_range", value.m_range); // float
		archive << make_nvp("m_spotAngle", value.m_spotAngle); // float
		archive << make_nvp("m_color", value.m_color); // FishEngine::Color
		archive << make_nvp("m_intensity", value.m_intensity); // float
		archive << make_nvp("m_shadowBias", value.m_shadowBias); // float
		archive << make_nvp("m_shadowNormalBias", value.m_shadowNormalBias); // float
		archive << make_nvp("m_shadowNearPlane", value.m_shadowNearPlane); // float
	}

	template<typename Archive>
	void Load ( Archive& archive, Light & value )
	{
		archive >> BaseClassWrapper<Behaviour>(value);
		archive >> make_nvp("m_type", value.m_type); // FishEngine::LightType
		archive >> make_nvp("m_range", value.m_range); // float
		archive >> make_nvp("m_spotAngle", value.m_spotAngle); // float
		archive >> make_nvp("m_color", value.m_color); // FishEngine::Color
		archive >> make_nvp("m_intensity", value.m_intensity); // float
		archive >> make_nvp("m_shadowBias", value.m_shadowBias); // float
		archive >> make_nvp("m_shadowNormalBias", value.m_shadowNormalBias); // float
		archive >> make_nvp("m_shadowNearPlane", value.m_shadowNearPlane); // float
	}


	// Material
	template<typename Archive>
	void Save ( Archive& archive, Material const & value )
	{
		archive << BaseClassWrapper<Object>(value);
		archive << make_nvp("m_shader", value.m_shader); // ShaderPtr
		archive << make_nvp("m_textures", value.m_textures); // std::map<std::string, TexturePtr>
		archive << make_nvp("m_uniforms", value.m_uniforms); // FishEngine::ShaderUniforms
		archive << make_nvp("m_properties", value.m_properties); // std::vector<MaterialProperty>
	}

	template<typename Archive>
	void Load ( Archive& archive, Material & value )
	{
		archive >> BaseClassWrapper<Object>(value);
		archive >> make_nvp("m_shader", value.m_shader); // ShaderPtr
		archive >> make_nvp("m_textures", value.m_textures); // std::map<std::string, TexturePtr>
		archive >> make_nvp("m_uniforms", value.m_uniforms); // FishEngine::ShaderUniforms
		archive >> make_nvp("m_properties", value.m_properties); // std::vector<MaterialProperty>
	}


	// Collider
	template<typename Archive>
	void Save ( Archive& archive, Collider const & value )
	{
		archive << BaseClassWrapper<Component>(value);
		archive << make_nvp("m_contactOffset", value.m_contactOffset); // float
		archive << make_nvp("m_enabled", value.m_enabled); // bool
		archive << make_nvp("m_isTrigger", value.m_isTrigger); // bool
	}

	template<typename Archive>
	void Load ( Archive& archive, Collider & value )
	{
		archive >> BaseClassWrapper<Component>(value);
		archive >> make_nvp("m_contactOffset", value.m_contactOffset); // float
		archive >> make_nvp("m_enabled", value.m_enabled); // bool
		archive >> make_nvp("m_isTrigger", value.m_isTrigger); // bool
	}


	// Script
	template<typename Archive>
	void Save ( Archive& archive, Script const & value )
	{
		archive << BaseClassWrapper<Behaviour>(value);
	}

	template<typename Archive>
	void Load ( Archive& archive, Script & value )
	{
		archive >> BaseClassWrapper<Behaviour>(value);
	}


	// MaterialProperty
	template<typename Archive>
	void Save ( Archive& archive, MaterialProperty const & value )
	{
		archive << make_nvp("name", value.name); // std::string
		archive << make_nvp("type", value.type); // FishEngine::MaterialPropertyType
	}

	template<typename Archive>
	void Load ( Archive& archive, MaterialProperty & value )
	{
		archive >> make_nvp("name", value.name); // std::string
		archive >> make_nvp("type", value.type); // FishEngine::MaterialPropertyType
	}


	// Vector2
	template<typename Archive>
	void Save ( Archive& archive, Vector2 const & value )
	{
		archive << make_nvp("x", value.x); // float
		archive << make_nvp("y", value.y); // float
	}

	template<typename Archive>
	void Load ( Archive& archive, Vector2 & value )
	{
		archive >> make_nvp("x", value.x); // float
		archive >> make_nvp("y", value.y); // float
	}


	// Vector3
	template<typename Archive>
	void Save ( Archive& archive, Vector3 const & value )
	{
		archive << make_nvp("x", value.x); // float
		archive << make_nvp("y", value.y); // float
		archive << make_nvp("z", value.z); // float
	}

	template<typename Archive>
	void Load ( Archive& archive, Vector3 & value )
	{
		archive >> make_nvp("x", value.x); // float
		archive >> make_nvp("y", value.y); // float
		archive >> make_nvp("z", value.z); // float
	}


	// Vector4
	template<typename Archive>
	void Save ( Archive& archive, Vector4 const & value )
	{
		archive << make_nvp("x", value.x); // float
		archive << make_nvp("y", value.y); // float
		archive << make_nvp("z", value.z); // float
		archive << make_nvp("w", value.w); // float
	}

	template<typename Archive>
	void Load ( Archive& archive, Vector4 & value )
	{
		archive >> make_nvp("x", value.x); // float
		archive >> make_nvp("y", value.y); // float
		archive >> make_nvp("z", value.z); // float
		archive >> make_nvp("w", value.w); // float
	}


	// Transform
	template<typename Archive>
	void Save ( Archive& archive, Transform const & value )
	{
		archive << BaseClassWrapper<Component>(value);
		archive << make_nvp("m_localPosition", value.m_localPosition); // FishEngine::Vector3
		archive << make_nvp("m_localScale", value.m_localScale); // FishEngine::Vector3
		archive << make_nvp("m_localRotation", value.m_localRotation); // FishEngine::Quaternion
		archive << make_nvp("m_parent", value.m_parent); // std::weak_ptr<Transform>
		archive << make_nvp("m_children", value.m_children); // std::list<std::weak_ptr<Transform> >
	}

	template<typename Archive>
	void Load ( Archive& archive, Transform & value )
	{
		archive >> BaseClassWrapper<Component>(value);
		archive >> make_nvp("m_localPosition", value.m_localPosition); // FishEngine::Vector3
		archive >> make_nvp("m_localScale", value.m_localScale); // FishEngine::Vector3
		archive >> make_nvp("m_localRotation", value.m_localRotation); // FishEngine::Quaternion
		archive >> make_nvp("m_parent", value.m_parent); // std::weak_ptr<Transform>
		archive >> make_nvp("m_children", value.m_children); // std::list<std::weak_ptr<Transform> >
	}


	// Texture
	template<typename Archive>
	void Save ( Archive& archive, Texture const & value )
	{
		archive << BaseClassWrapper<Object>(value);
		archive << make_nvp("m_height", value.m_height); // uint32_t
		archive << make_nvp("m_width", value.m_width); // uint32_t
		archive << make_nvp("m_anisoLevel", value.m_anisoLevel); // int
		archive << make_nvp("m_dimension", value.m_dimension); // FishEngine::TextureDimension
		archive << make_nvp("m_filterMode", value.m_filterMode); // FishEngine::FilterMode
		archive << make_nvp("m_wrapMode", value.m_wrapMode); // FishEngine::TextureWrapMode
	}

	template<typename Archive>
	void Load ( Archive& archive, Texture & value )
	{
		archive >> BaseClassWrapper<Object>(value);
		archive >> make_nvp("m_height", value.m_height); // uint32_t
		archive >> make_nvp("m_width", value.m_width); // uint32_t
		archive >> make_nvp("m_anisoLevel", value.m_anisoLevel); // int
		archive >> make_nvp("m_dimension", value.m_dimension); // FishEngine::TextureDimension
		archive >> make_nvp("m_filterMode", value.m_filterMode); // FishEngine::FilterMode
		archive >> make_nvp("m_wrapMode", value.m_wrapMode); // FishEngine::TextureWrapMode
	}


	// Matrix4x4
	template<typename Archive>
	void Save ( Archive& archive, Matrix4x4 const & value )
	{
		
	}

	template<typename Archive>
	void Load ( Archive& archive, Matrix4x4 & value )
	{
		
	}


	// AnimationNode
	template<typename Archive>
	void Save ( Archive& archive, AnimationNode const & value )
	{
		archive << make_nvp("name", value.name); // std::string
		archive << make_nvp("positionKeys", value.positionKeys); // std::vector<Vector3Key>
		archive << make_nvp("rotationKeys", value.rotationKeys); // std::vector<QuaternionKey>
		archive << make_nvp("scalingKeys", value.scalingKeys); // std::vector<Vector3Key>
	}

	template<typename Archive>
	void Load ( Archive& archive, AnimationNode & value )
	{
		archive >> make_nvp("name", value.name); // std::string
		archive >> make_nvp("positionKeys", value.positionKeys); // std::vector<Vector3Key>
		archive >> make_nvp("rotationKeys", value.rotationKeys); // std::vector<QuaternionKey>
		archive >> make_nvp("scalingKeys", value.scalingKeys); // std::vector<Vector3Key>
	}


	// UniformInfo
	template<typename Archive>
	void Save ( Archive& archive, UniformInfo const & value )
	{
		archive << make_nvp("type", value.type); // GLenum
		archive << make_nvp("name", value.name); // std::string
		archive << make_nvp("location", value.location); // GLuint
		archive << make_nvp("textureBindPoint", value.textureBindPoint); // int
		archive << make_nvp("binded", value.binded); // bool
	}

	template<typename Archive>
	void Load ( Archive& archive, UniformInfo & value )
	{
		archive >> make_nvp("type", value.type); // GLenum
		archive >> make_nvp("name", value.name); // std::string
		archive >> make_nvp("location", value.location); // GLuint
		archive >> make_nvp("textureBindPoint", value.textureBindPoint); // int
		archive >> make_nvp("binded", value.binded); // bool
	}


	// SphereCollider
	template<typename Archive>
	void Save ( Archive& archive, SphereCollider const & value )
	{
		archive << BaseClassWrapper<Collider>(value);
		archive << make_nvp("m_center", value.m_center); // FishEngine::Vector3
		archive << make_nvp("m_radius", value.m_radius); // float
	}

	template<typename Archive>
	void Load ( Archive& archive, SphereCollider & value )
	{
		archive >> BaseClassWrapper<Collider>(value);
		archive >> make_nvp("m_center", value.m_center); // FishEngine::Vector3
		archive >> make_nvp("m_radius", value.m_radius); // float
	}


	// ShaderUniforms
	template<typename Archive>
	void Save ( Archive& archive, ShaderUniforms const & value )
	{
		archive << make_nvp("mat4s", value.mat4s); // std::map<std::string, Matrix4x4>
		archive << make_nvp("vec2s", value.vec2s); // std::map<std::string, Vector2>
		archive << make_nvp("vec3s", value.vec3s); // std::map<std::string, Vector3>
		archive << make_nvp("vec4s", value.vec4s); // std::map<std::string, Vector4>
		archive << make_nvp("floats", value.floats); // std::map<std::string, float>
	}

	template<typename Archive>
	void Load ( Archive& archive, ShaderUniforms & value )
	{
		archive >> make_nvp("mat4s", value.mat4s); // std::map<std::string, Matrix4x4>
		archive >> make_nvp("vec2s", value.vec2s); // std::map<std::string, Vector2>
		archive >> make_nvp("vec3s", value.vec3s); // std::map<std::string, Vector3>
		archive >> make_nvp("vec4s", value.vec4s); // std::map<std::string, Vector4>
		archive >> make_nvp("floats", value.floats); // std::map<std::string, float>
	}


	// Camera
	template<typename Archive>
	void Save ( Archive& archive, Camera const & value )
	{
		archive << BaseClassWrapper<Behaviour>(value);
		archive << make_nvp("m_fieldOfView", value.m_fieldOfView); // float
		archive << make_nvp("m_orthographicSize", value.m_orthographicSize); // float
		archive << make_nvp("m_aspect", value.m_aspect); // float
		archive << make_nvp("m_isAspectSet", value.m_isAspectSet); // bool
		archive << make_nvp("m_farClipPlane", value.m_farClipPlane); // float
		archive << make_nvp("m_nearClipPlane", value.m_nearClipPlane); // float
		archive << make_nvp("m_viewport", value.m_viewport); // FishEngine::Vector4
		archive << make_nvp("m_isDirty", value.m_isDirty); // bool
		archive << make_nvp("m_cameraType", value.m_cameraType); // FishEngine::CameraType
		archive << make_nvp("m_orthographic", value.m_orthographic); // bool
	}

	template<typename Archive>
	void Load ( Archive& archive, Camera & value )
	{
		archive >> BaseClassWrapper<Behaviour>(value);
		archive >> make_nvp("m_fieldOfView", value.m_fieldOfView); // float
		archive >> make_nvp("m_orthographicSize", value.m_orthographicSize); // float
		archive >> make_nvp("m_aspect", value.m_aspect); // float
		archive >> make_nvp("m_isAspectSet", value.m_isAspectSet); // bool
		archive >> make_nvp("m_farClipPlane", value.m_farClipPlane); // float
		archive >> make_nvp("m_nearClipPlane", value.m_nearClipPlane); // float
		archive >> make_nvp("m_viewport", value.m_viewport); // FishEngine::Vector4
		archive >> make_nvp("m_isDirty", value.m_isDirty); // bool
		archive >> make_nvp("m_cameraType", value.m_cameraType); // FishEngine::CameraType
		archive >> make_nvp("m_orthographic", value.m_orthographic); // bool
	}


	// Frustum
	template<typename Archive>
	void Save ( Archive& archive, Frustum const & value )
	{
		archive << make_nvp("fov", value.fov); // float
		archive << make_nvp("maxRange", value.maxRange); // float
		archive << make_nvp("minRange", value.minRange); // float
		archive << make_nvp("aspect", value.aspect); // float
	}

	template<typename Archive>
	void Load ( Archive& archive, Frustum & value )
	{
		archive >> make_nvp("fov", value.fov); // float
		archive >> make_nvp("maxRange", value.maxRange); // float
		archive >> make_nvp("minRange", value.minRange); // float
		archive >> make_nvp("aspect", value.aspect); // float
	}


	// Object
	template<typename Archive>
	void Save ( Archive& archive, Object const & value )
	{
		archive << make_nvp("m_hideFlags", value.m_hideFlags); // FishEngine::HideFlags
		archive << make_nvp("m_name", value.m_name); // std::string
		archive << make_nvp("m_uuid", value.m_uuid); // UUID
	}

	template<typename Archive>
	void Load ( Archive& archive, Object & value )
	{
		archive >> make_nvp("m_hideFlags", value.m_hideFlags); // FishEngine::HideFlags
		archive >> make_nvp("m_name", value.m_name); // std::string
		archive >> make_nvp("m_uuid", value.m_uuid); // UUID
	}


	// Component
	template<typename Archive>
	void Save ( Archive& archive, Component const & value )
	{
		archive << BaseClassWrapper<Object>(value);
		archive << make_nvp("m_gameObject", value.m_gameObject); // std::weak_ptr<GameObject>
	}

	template<typename Archive>
	void Load ( Archive& archive, Component & value )
	{
		archive >> BaseClassWrapper<Object>(value);
		archive >> make_nvp("m_gameObject", value.m_gameObject); // std::weak_ptr<GameObject>
	}


	// Shader
	template<typename Archive>
	void Save ( Archive& archive, Shader const & value )
	{
		archive << BaseClassWrapper<Object>(value);
		archive << make_nvp("m_uniforms", value.m_uniforms); // std::vector<UniformInfo>
		archive << make_nvp("m_cullface", value.m_cullface); // FishEngine::Cullface
		archive << make_nvp("m_ZWrite", value.m_ZWrite); // bool
		archive << make_nvp("m_blend", value.m_blend); // bool
		archive << make_nvp("m_deferred", value.m_deferred); // bool
		archive << make_nvp("m_keywords", value.m_keywords); // ShaderKeywords
	}

	template<typename Archive>
	void Load ( Archive& archive, Shader & value )
	{
		archive >> BaseClassWrapper<Object>(value);
		archive >> make_nvp("m_uniforms", value.m_uniforms); // std::vector<UniformInfo>
		archive >> make_nvp("m_cullface", value.m_cullface); // FishEngine::Cullface
		archive >> make_nvp("m_ZWrite", value.m_ZWrite); // bool
		archive >> make_nvp("m_blend", value.m_blend); // bool
		archive >> make_nvp("m_deferred", value.m_deferred); // bool
		archive >> make_nvp("m_keywords", value.m_keywords); // ShaderKeywords
	}


	// TagManager
	template<typename Archive>
	void Save ( Archive& archive, TagManager const & value )
	{
		
	}

	template<typename Archive>
	void Load ( Archive& archive, TagManager & value )
	{
		
	}


	// Behaviour
	template<typename Archive>
	void Save ( Archive& archive, Behaviour const & value )
	{
		archive << BaseClassWrapper<Component>(value);
		archive << make_nvp("m_enabled", value.m_enabled); // bool
	}

	template<typename Archive>
	void Load ( Archive& archive, Behaviour & value )
	{
		archive >> BaseClassWrapper<Component>(value);
		archive >> make_nvp("m_enabled", value.m_enabled); // bool
	}


	// Int4
	template<typename Archive>
	void Save ( Archive& archive, Int4 const & value )
	{
		archive << make_nvp("x", value.x); // int
		archive << make_nvp("y", value.y); // int
		archive << make_nvp("z", value.z); // int
		archive << make_nvp("w", value.w); // int
	}

	template<typename Archive>
	void Load ( Archive& archive, Int4 & value )
	{
		archive >> make_nvp("x", value.x); // int
		archive >> make_nvp("y", value.y); // int
		archive >> make_nvp("z", value.z); // int
		archive >> make_nvp("w", value.w); // int
	}


	// Quaternion
	template<typename Archive>
	void Save ( Archive& archive, Quaternion const & value )
	{
		archive << make_nvp("x", value.x); // float
		archive << make_nvp("y", value.y); // float
		archive << make_nvp("z", value.z); // float
		archive << make_nvp("w", value.w); // float
	}

	template<typename Archive>
	void Load ( Archive& archive, Quaternion & value )
	{
		archive >> make_nvp("x", value.x); // float
		archive >> make_nvp("y", value.y); // float
		archive >> make_nvp("z", value.z); // float
		archive >> make_nvp("w", value.w); // float
	}


	// Mesh
	template<typename Archive>
	void Save ( Archive& archive, Mesh const & value )
	{
		archive << BaseClassWrapper<Object>(value);
		archive << make_nvp("m_skinned", value.m_skinned); // bool
		archive << make_nvp("m_isReadable", value.m_isReadable); // bool
		archive << make_nvp("m_uploaded", value.m_uploaded); // bool
		archive << make_nvp("m_vertexCount", value.m_vertexCount); // uint32_t
		archive << make_nvp("m_triangleCount", value.m_triangleCount); // uint32_t
		archive << make_nvp("m_bounds", value.m_bounds); // FishEngine::Bounds
		archive << make_nvp("m_positionBuffer", value.m_positionBuffer); // std::vector<float>
		archive << make_nvp("m_normalBuffer", value.m_normalBuffer); // std::vector<float>
		archive << make_nvp("m_uvBuffer", value.m_uvBuffer); // std::vector<float>
		archive << make_nvp("m_tangentBuffer", value.m_tangentBuffer); // std::vector<float>
		archive << make_nvp("m_indexBuffer", value.m_indexBuffer); // std::vector<uint32_t>
		archive << make_nvp("m_boneIndexBuffer", value.m_boneIndexBuffer); // std::vector<Int4>
		archive << make_nvp("m_boneWeightBuffer", value.m_boneWeightBuffer); // std::vector<Vector4>
		archive << make_nvp("m_boneNameToIndex", value.m_boneNameToIndex); // std::map<std::string, int>
		archive << make_nvp("m_bindposes", value.m_bindposes); // std::vector<Matrix4x4>
		archive << make_nvp("m_VAO", value.m_VAO); // GLuint
		archive << make_nvp("m_indexVBO", value.m_indexVBO); // GLuint
		archive << make_nvp("m_positionVBO", value.m_positionVBO); // GLuint
		archive << make_nvp("m_normalVBO", value.m_normalVBO); // GLuint
		archive << make_nvp("m_uvVBO", value.m_uvVBO); // GLuint
		archive << make_nvp("m_tangentVBO", value.m_tangentVBO); // GLuint
		archive << make_nvp("m_boneIndexVBO", value.m_boneIndexVBO); // GLuint
		archive << make_nvp("m_boneWeightVBO", value.m_boneWeightVBO); // GLuint
	}

	template<typename Archive>
	void Load ( Archive& archive, Mesh & value )
	{
		archive >> BaseClassWrapper<Object>(value);
		archive >> make_nvp("m_skinned", value.m_skinned); // bool
		archive >> make_nvp("m_isReadable", value.m_isReadable); // bool
		archive >> make_nvp("m_uploaded", value.m_uploaded); // bool
		archive >> make_nvp("m_vertexCount", value.m_vertexCount); // uint32_t
		archive >> make_nvp("m_triangleCount", value.m_triangleCount); // uint32_t
		archive >> make_nvp("m_bounds", value.m_bounds); // FishEngine::Bounds
		archive >> make_nvp("m_positionBuffer", value.m_positionBuffer); // std::vector<float>
		archive >> make_nvp("m_normalBuffer", value.m_normalBuffer); // std::vector<float>
		archive >> make_nvp("m_uvBuffer", value.m_uvBuffer); // std::vector<float>
		archive >> make_nvp("m_tangentBuffer", value.m_tangentBuffer); // std::vector<float>
		archive >> make_nvp("m_indexBuffer", value.m_indexBuffer); // std::vector<uint32_t>
		archive >> make_nvp("m_boneIndexBuffer", value.m_boneIndexBuffer); // std::vector<Int4>
		archive >> make_nvp("m_boneWeightBuffer", value.m_boneWeightBuffer); // std::vector<Vector4>
		archive >> make_nvp("m_boneNameToIndex", value.m_boneNameToIndex); // std::map<std::string, int>
		archive >> make_nvp("m_bindposes", value.m_bindposes); // std::vector<Matrix4x4>
		archive >> make_nvp("m_VAO", value.m_VAO); // GLuint
		archive >> make_nvp("m_indexVBO", value.m_indexVBO); // GLuint
		archive >> make_nvp("m_positionVBO", value.m_positionVBO); // GLuint
		archive >> make_nvp("m_normalVBO", value.m_normalVBO); // GLuint
		archive >> make_nvp("m_uvVBO", value.m_uvVBO); // GLuint
		archive >> make_nvp("m_tangentVBO", value.m_tangentVBO); // GLuint
		archive >> make_nvp("m_boneIndexVBO", value.m_boneIndexVBO); // GLuint
		archive >> make_nvp("m_boneWeightVBO", value.m_boneWeightVBO); // GLuint
	}


	// ShaderCompiler
	template<typename Archive>
	void Save ( Archive& archive, ShaderCompiler const & value )
	{
		archive << make_nvp("m_hasGeometryShader", value.m_hasGeometryShader); // bool
		archive << make_nvp("m_settings", value.m_settings); // std::map<std::string, std::string>
		archive << make_nvp("m_error", value.m_error); // FishEngine::ShaderCompilerErrorCode
		archive << make_nvp("m_errorString", value.m_errorString); // std::string
		archive << make_nvp("m_path", value.m_path); // Path
		archive << make_nvp("m_includeDepth", value.m_includeDepth); // uint32_t
	}

	template<typename Archive>
	void Load ( Archive& archive, ShaderCompiler & value )
	{
		archive >> make_nvp("m_hasGeometryShader", value.m_hasGeometryShader); // bool
		archive >> make_nvp("m_settings", value.m_settings); // std::map<std::string, std::string>
		archive >> make_nvp("m_error", value.m_error); // FishEngine::ShaderCompilerErrorCode
		archive >> make_nvp("m_errorString", value.m_errorString); // std::string
		archive >> make_nvp("m_path", value.m_path); // Path
		archive >> make_nvp("m_includeDepth", value.m_includeDepth); // uint32_t
	}


	// Int3
	template<typename Archive>
	void Save ( Archive& archive, Int3 const & value )
	{
		archive << make_nvp("x", value.x); // int
		archive << make_nvp("y", value.y); // int
		archive << make_nvp("z", value.z); // int
	}

	template<typename Archive>
	void Load ( Archive& archive, Int3 & value )
	{
		archive >> make_nvp("x", value.x); // int
		archive >> make_nvp("y", value.y); // int
		archive >> make_nvp("z", value.z); // int
	}


	// Int2
	template<typename Archive>
	void Save ( Archive& archive, Int2 const & value )
	{
		archive << make_nvp("x", value.x); // int
		archive << make_nvp("y", value.y); // int
	}

	template<typename Archive>
	void Load ( Archive& archive, Int2 & value )
	{
		archive >> make_nvp("x", value.x); // int
		archive >> make_nvp("y", value.y); // int
	}


	// BoneWeight
	template<typename Archive>
	void Save ( Archive& archive, BoneWeight const & value )
	{
		archive << make_nvp("boneIndex", value.boneIndex); // int [4]
		archive << make_nvp("weight", value.weight); // float [4]
	}

	template<typename Archive>
	void Load ( Archive& archive, BoneWeight & value )
	{
		archive >> make_nvp("boneIndex", value.boneIndex); // int [4]
		archive >> make_nvp("weight", value.weight); // float [4]
	}


	// Texture2D
	template<typename Archive>
	void Save ( Archive& archive, Texture2D const & value )
	{
		archive << BaseClassWrapper<Texture>(value);
		archive << make_nvp("m_format", value.m_format); // FishEngine::TextureFormat
		archive << make_nvp("m_mipmapCount", value.m_mipmapCount); // uint32_t
	}

	template<typename Archive>
	void Load ( Archive& archive, Texture2D & value )
	{
		archive >> BaseClassWrapper<Texture>(value);
		archive >> make_nvp("m_format", value.m_format); // FishEngine::TextureFormat
		archive >> make_nvp("m_mipmapCount", value.m_mipmapCount); // uint32_t
	}


	// Renderer
	template<typename Archive>
	void Save ( Archive& archive, Renderer const & value )
	{
		archive << BaseClassWrapper<Component>(value);
		archive << make_nvp("m_enabled", value.m_enabled); // bool
		archive << make_nvp("m_materials", value.m_materials); // std::vector<MaterialPtr>
		archive << make_nvp("m_shadowCastingMode", value.m_shadowCastingMode); // FishEngine::ShadowCastingMode
		archive << make_nvp("m_receiveShadows", value.m_receiveShadows); // bool
	}

	template<typename Archive>
	void Load ( Archive& archive, Renderer & value )
	{
		archive >> BaseClassWrapper<Component>(value);
		archive >> make_nvp("m_enabled", value.m_enabled); // bool
		archive >> make_nvp("m_materials", value.m_materials); // std::vector<MaterialPtr>
		archive >> make_nvp("m_shadowCastingMode", value.m_shadowCastingMode); // FishEngine::ShadowCastingMode
		archive >> make_nvp("m_receiveShadows", value.m_receiveShadows); // bool
	}

	// SkinnedMeshRenderer
	template<typename Archive>
	void Save ( Archive& archive, SkinnedMeshRenderer const & value )
	{
		archive << BaseClassWrapper<Renderer>(value);
		archive << make_nvp("m_sharedMesh", value.m_sharedMesh); // MeshPtr
		archive << make_nvp("m_avatar", value.m_avatar); // AvatarPtr
		archive << make_nvp("m_rootBone", value.m_rootBone); // std::weak_ptr<Transform>
		archive << make_nvp("m_bones", value.m_bones); // std::vector<std::weak_ptr<Transform> >
		archive << make_nvp("m_matrixPalette", value.m_matrixPalette); // std::vector<Matrix4x4>
	}

	template<typename Archive>
	void Load ( Archive& archive, SkinnedMeshRenderer & value )
	{
		archive >> BaseClassWrapper<Renderer>(value);
		archive >> make_nvp("m_sharedMesh", value.m_sharedMesh); // MeshPtr
		archive >> make_nvp("m_avatar", value.m_avatar); // AvatarPtr
		archive >> make_nvp("m_rootBone", value.m_rootBone); // std::weak_ptr<Transform>
		archive >> make_nvp("m_bones", value.m_bones); // std::vector<std::weak_ptr<Transform> >
		archive >> make_nvp("m_matrixPalette", value.m_matrixPalette); // std::vector<Matrix4x4>
	}


	// Cubemap
	template<typename Archive>
	void Save ( Archive& archive, Cubemap const & value )
	{
		archive << BaseClassWrapper<Texture>(value);
		archive << make_nvp("m_format", value.m_format); // FishEngine::TextureFormat
		archive << make_nvp("m_mipmapCount", value.m_mipmapCount); // uint32_t
	}

	template<typename Archive>
	void Load ( Archive& archive, Cubemap & value )
	{
		archive >> BaseClassWrapper<Texture>(value);
		archive >> make_nvp("m_format", value.m_format); // FishEngine::TextureFormat
		archive >> make_nvp("m_mipmapCount", value.m_mipmapCount); // uint32_t
	}


	// Vector3Key
	template<typename Archive>
	void Save ( Archive& archive, Vector3Key const & value )
	{
		archive << make_nvp("time", value.time); // float
		archive << make_nvp("value", value.value); // FishEngine::Vector3
	}

	template<typename Archive>
	void Load ( Archive& archive, Vector3Key & value )
	{
		archive >> make_nvp("time", value.time); // float
		archive >> make_nvp("value", value.value); // FishEngine::Vector3
	}


	// Bounds
	template<typename Archive>
	void Save ( Archive& archive, Bounds const & value )
	{
		archive << make_nvp("m_center", value.m_center); // FishEngine::Vector3
		archive << make_nvp("m_extents", value.m_extents); // FishEngine::Vector3
	}

	template<typename Archive>
	void Load ( Archive& archive, Bounds & value )
	{
		archive >> make_nvp("m_center", value.m_center); // FishEngine::Vector3
		archive >> make_nvp("m_extents", value.m_extents); // FishEngine::Vector3
	}


	// Applicaiton
	template<typename Archive>
	void Save ( Archive& archive, Applicaiton const & value )
	{
		
	}

	template<typename Archive>
	void Load ( Archive& archive, Applicaiton & value )
	{
		
	}


	// QuaternionKey
	template<typename Archive>
	void Save ( Archive& archive, QuaternionKey const & value )
	{
		archive << make_nvp("time", value.time); // float
		archive << make_nvp("value", value.value); // FishEngine::Quaternion
	}

	template<typename Archive>
	void Load ( Archive& archive, QuaternionKey & value )
	{
		archive >> make_nvp("time", value.time); // float
		archive >> make_nvp("value", value.value); // FishEngine::Quaternion
	}


	// Avatar
	template<typename Archive>
	void Save ( Archive& archive, Avatar const & value )
	{
		archive << BaseClassWrapper<Object>(value);
		archive << make_nvp("m_boneToIndex", value.m_boneToIndex); // std::map<std::string, int>
		archive << make_nvp("m_indexToBone", value.m_indexToBone); // std::map<int, std::string>
	}

	template<typename Archive>
	void Load ( Archive& archive, Avatar & value )
	{
		archive >> BaseClassWrapper<Object>(value);
		archive >> make_nvp("m_boneToIndex", value.m_boneToIndex); // std::map<std::string, int>
		archive >> make_nvp("m_indexToBone", value.m_indexToBone); // std::map<int, std::string>
	}


	// LayerMask
	template<typename Archive>
	void Save ( Archive& archive, LayerMask const & value )
	{
		archive << make_nvp("m_value", value.m_value); // int
	}

	template<typename Archive>
	void Load ( Archive& archive, LayerMask & value )
	{
		archive >> make_nvp("m_value", value.m_value); // int
	}


	// CapsuleCollider
	template<typename Archive>
	void Save ( Archive& archive, CapsuleCollider const & value )
	{
		archive << BaseClassWrapper<Collider>(value);
		archive << make_nvp("m_center", value.m_center); // FishEngine::Vector3
		archive << make_nvp("m_direction", value.m_direction); // int
		archive << make_nvp("m_height", value.m_height); // float
		archive << make_nvp("m_radius", value.m_radius); // float
	}

	template<typename Archive>
	void Load ( Archive& archive, CapsuleCollider & value )
	{
		archive >> BaseClassWrapper<Collider>(value);
		archive >> make_nvp("m_center", value.m_center); // FishEngine::Vector3
		archive >> make_nvp("m_direction", value.m_direction); // int
		archive >> make_nvp("m_height", value.m_height); // float
		archive >> make_nvp("m_radius", value.m_radius); // float
	}


	// Animator
	template<typename Archive>
	void Save ( Archive& archive, Animator const & value )
	{
		archive << BaseClassWrapper<Component>(value);
		archive << make_nvp("m_time", value.m_time); // float
		archive << make_nvp("m_playing", value.m_playing); // bool
		archive << make_nvp("m_playingOnce", value.m_playingOnce); // bool
		archive << make_nvp("m_playOneFrame", value.m_playOneFrame); // bool
		archive << make_nvp("m_currentFrame", value.m_currentFrame); // int
		archive << make_nvp("m_avatar", value.m_avatar); // AvatarPtr
		archive << make_nvp("m_nameToGameObject", value.m_nameToGameObject); // std::map<std::string, std::weak_ptr<GameObject> >
	}

	template<typename Archive>
	void Load ( Archive& archive, Animator & value )
	{
		archive >> BaseClassWrapper<Component>(value);
		archive >> make_nvp("m_time", value.m_time); // float
		archive >> make_nvp("m_playing", value.m_playing); // bool
		archive >> make_nvp("m_playingOnce", value.m_playingOnce); // bool
		archive >> make_nvp("m_playOneFrame", value.m_playOneFrame); // bool
		archive >> make_nvp("m_currentFrame", value.m_currentFrame); // int
		archive >> make_nvp("m_avatar", value.m_avatar); // AvatarPtr
		archive >> make_nvp("m_nameToGameObject", value.m_nameToGameObject); // std::map<std::string, std::weak_ptr<GameObject> >
	}


	// CameraController
	template<typename Archive>
	void Save ( Archive& archive, CameraController const & value )
	{
		archive << BaseClassWrapper<Script>(value);
		archive << make_nvp("m_isRotating", value.m_isRotating); // bool
		archive << make_nvp("m_lookAtMode", value.m_lookAtMode); // bool
		archive << make_nvp("m_rotateSpeed", value.m_rotateSpeed); // float
		archive << make_nvp("m_dragSpeed", value.m_dragSpeed); // float
		archive << make_nvp("m_originalPosition", value.m_originalPosition); // FishEngine::Vector3
		archive << make_nvp("m_originalRotation", value.m_originalRotation); // FishEngine::Quaternion
		archive << make_nvp("m_originalScale", value.m_originalScale); // FishEngine::Vector3
	}

	template<typename Archive>
	void Load ( Archive& archive, CameraController & value )
	{
		archive >> BaseClassWrapper<Script>(value);
		archive >> make_nvp("m_isRotating", value.m_isRotating); // bool
		archive >> make_nvp("m_lookAtMode", value.m_lookAtMode); // bool
		archive >> make_nvp("m_rotateSpeed", value.m_rotateSpeed); // float
		archive >> make_nvp("m_dragSpeed", value.m_dragSpeed); // float
		archive >> make_nvp("m_originalPosition", value.m_originalPosition); // FishEngine::Vector3
		archive >> make_nvp("m_originalRotation", value.m_originalRotation); // FishEngine::Quaternion
		archive >> make_nvp("m_originalScale", value.m_originalScale); // FishEngine::Vector3
	}


	// BoxCollider
	template<typename Archive>
	void Save ( Archive& archive, BoxCollider const & value )
	{
		archive << BaseClassWrapper<Collider>(value);
		archive << make_nvp("m_center", value.m_center); // FishEngine::Vector3
		archive << make_nvp("m_size", value.m_size); // FishEngine::Vector3
	}

	template<typename Archive>
	void Load ( Archive& archive, BoxCollider & value )
	{
		archive >> BaseClassWrapper<Collider>(value);
		archive >> make_nvp("m_center", value.m_center); // FishEngine::Vector3
		archive >> make_nvp("m_size", value.m_size); // FishEngine::Vector3
	}


	// GameObject
	template<typename Archive>
	void Save ( Archive& archive, GameObject const & value )
	{
		archive << BaseClassWrapper<Object>(value);
		archive << make_nvp("m_components", value.m_components); // std::list<ComponentPtr>
		archive << make_nvp("m_activeSelf", value.m_activeSelf); // bool
		archive << make_nvp("m_layer", value.m_layer); // int
		archive << make_nvp("m_tagIndex", value.m_tagIndex); // int
		archive << make_nvp("m_transform", value.m_transform); // TransformPtr
	}

	template<typename Archive>
	void Load ( Archive& archive, GameObject & value )
	{
		archive >> BaseClassWrapper<Object>(value);
		archive >> make_nvp("m_components", value.m_components); // std::list<ComponentPtr>
		archive >> make_nvp("m_activeSelf", value.m_activeSelf); // bool
		archive >> make_nvp("m_layer", value.m_layer); // int
		archive >> make_nvp("m_tagIndex", value.m_tagIndex); // int
		archive >> make_nvp("m_transform", value.m_transform); // TransformPtr
	}


	// MeshFilter
	template<typename Archive>
	void Save ( Archive& archive, MeshFilter const & value )
	{
		archive << BaseClassWrapper<Component>(value);
		archive << make_nvp("m_mesh", value.m_mesh); // MeshPtr
	}

	template<typename Archive>
	void Load ( Archive& archive, MeshFilter & value )
	{
		archive >> BaseClassWrapper<Component>(value);
		archive >> make_nvp("m_mesh", value.m_mesh); // MeshPtr
	}


	// Scene
	template<typename Archive>
	void Save ( Archive& archive, Scene const & value )
	{
		
	}

	template<typename Archive>
	void Load ( Archive& archive, Scene & value )
	{
		
	}


	// TransformationKey
	template<typename Archive>
	void Save ( Archive& archive, TransformationKey const & value )
	{
		archive << make_nvp("time", value.time); // float
		archive << make_nvp("value", value.value); // FishEngine::Matrix4x4
	}

	template<typename Archive>
	void Load ( Archive& archive, TransformationKey & value )
	{
		archive >> make_nvp("time", value.time); // float
		archive >> make_nvp("value", value.value); // FishEngine::Matrix4x4
	}


	// Animation
	template<typename Archive>
	void Save ( Archive& archive, Animation const & value )
	{
		archive << make_nvp("name", value.name); // std::string
		archive << make_nvp("duration", value.duration); // float
		archive << make_nvp("ticksPerSecond", value.ticksPerSecond); // float
		archive << make_nvp("channels", value.channels); // std::map<std::string, AnimationNode>
	}

	template<typename Archive>
	void Load ( Archive& archive, Animation & value )
	{
		archive >> make_nvp("name", value.name); // std::string
		archive >> make_nvp("duration", value.duration); // float
		archive >> make_nvp("ticksPerSecond", value.ticksPerSecond); // float
		archive >> make_nvp("channels", value.channels); // std::map<std::string, AnimationNode>
	}


	// Color
	template<typename Archive>
	void Save ( Archive& archive, Color const & value )
	{
		archive << make_nvp("r", value.r); // float
		archive << make_nvp("g", value.g); // float
		archive << make_nvp("b", value.b); // float
	}

	template<typename Archive>
	void Load ( Archive& archive, Color & value )
	{
		archive >> make_nvp("r", value.r); // float
		archive >> make_nvp("g", value.g); // float
		archive >> make_nvp("b", value.b); // float
	}


	// MeshRenderer
	template<typename Archive>
	void Save ( Archive& archive, MeshRenderer const & value )
	{
		archive << BaseClassWrapper<Renderer>(value);
	}

	template<typename Archive>
	void Load ( Archive& archive, MeshRenderer & value )
	{
		archive >> BaseClassWrapper<Renderer>(value);
	}


	// Skybox
	template<typename Archive>
	void Save ( Archive& archive, Skybox const & value )
	{
		archive << BaseClassWrapper<Behaviour>(value);
		archive << make_nvp("m_material", value.m_material); // MaterialPtr
	}

	template<typename Archive>
	void Load ( Archive& archive, Skybox & value )
	{
		archive >> BaseClassWrapper<Behaviour>(value);
		archive >> make_nvp("m_material", value.m_material); // MaterialPtr
	}


	// GameApp
	template<typename Archive>
	void Save ( Archive& archive, GameApp const & value )
	{
		
	}

	template<typename Archive>
	void Load ( Archive& archive, GameApp & value )
	{
		
	}


	// Ray
	template<typename Archive>
	void Save ( Archive& archive, Ray const & value )
	{
		archive << make_nvp("origin", value.origin); // FishEngine::Vector3
		archive << make_nvp("direction", value.direction); // FishEngine::Vector3
	}

	template<typename Archive>
	void Load ( Archive& archive, Ray & value )
	{
		archive >> make_nvp("origin", value.origin); // FishEngine::Vector3
		archive >> make_nvp("direction", value.direction); // FishEngine::Vector3
	}

} // namespace FishEngine

namespace FishEngine
{
    template<class Archive>
    static void DynamicSerializeObject(Archive & archive, std::shared_ptr<Object> obj)
    {
        const int id = obj->ClassID();
        switch (id)
        {
        
        case ClassID<Rigidbody>():
            archive << *std::dynamic_pointer_cast<Rigidbody>(obj);
            break;
        case ClassID<Light>():
            archive << *std::dynamic_pointer_cast<Light>(obj);
            break;
        case ClassID<Material>():
            archive << *std::dynamic_pointer_cast<Material>(obj);
            break;
        case ClassID<Collider>():
            archive << *std::dynamic_pointer_cast<Collider>(obj);
            break;
        case ClassID<Script>():
            archive << *std::dynamic_pointer_cast<Script>(obj);
            break;
        case ClassID<Transform>():
            archive << *std::dynamic_pointer_cast<Transform>(obj);
            break;
        case ClassID<Texture>():
            archive << *std::dynamic_pointer_cast<Texture>(obj);
            break;
        case ClassID<SphereCollider>():
            archive << *std::dynamic_pointer_cast<SphereCollider>(obj);
            break;
        case ClassID<Camera>():
            archive << *std::dynamic_pointer_cast<Camera>(obj);
            break;
        case ClassID<Component>():
            archive << *std::dynamic_pointer_cast<Component>(obj);
            break;
        case ClassID<Shader>():
            archive << *std::dynamic_pointer_cast<Shader>(obj);
            break;
        case ClassID<Behaviour>():
            archive << *std::dynamic_pointer_cast<Behaviour>(obj);
            break;
        case ClassID<Mesh>():
            archive << *std::dynamic_pointer_cast<Mesh>(obj);
            break;
        case ClassID<Texture2D>():
            archive << *std::dynamic_pointer_cast<Texture2D>(obj);
            break;
        case ClassID<Renderer>():
            archive << *std::dynamic_pointer_cast<Renderer>(obj);
            break;
        case ClassID<SkinnedMeshRenderer>():
            archive << *std::dynamic_pointer_cast<SkinnedMeshRenderer>(obj);
            break;
        case ClassID<Cubemap>():
            archive << *std::dynamic_pointer_cast<Cubemap>(obj);
            break;
        case ClassID<Avatar>():
            archive << *std::dynamic_pointer_cast<Avatar>(obj);
            break;
        case ClassID<CapsuleCollider>():
            archive << *std::dynamic_pointer_cast<CapsuleCollider>(obj);
            break;
        case ClassID<Animator>():
            archive << *std::dynamic_pointer_cast<Animator>(obj);
            break;
        case ClassID<CameraController>():
            archive << *std::dynamic_pointer_cast<CameraController>(obj);
            break;
        case ClassID<BoxCollider>():
            archive << *std::dynamic_pointer_cast<BoxCollider>(obj);
            break;
        case ClassID<GameObject>():
            archive << *std::dynamic_pointer_cast<GameObject>(obj);
            break;
        case ClassID<MeshFilter>():
            archive << *std::dynamic_pointer_cast<MeshFilter>(obj);
            break;
        case ClassID<MeshRenderer>():
            archive << *std::dynamic_pointer_cast<MeshRenderer>(obj);
            break;
        case ClassID<Skybox>():
            archive << *std::dynamic_pointer_cast<Skybox>(obj);
            break;;
        default:
            abort();
        }
    }
}
